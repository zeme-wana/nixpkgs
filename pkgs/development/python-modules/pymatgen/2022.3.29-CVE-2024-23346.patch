Based on upstream c231cbd3d5147ee920a37b6ee9dd236b376bcf5a, adjusted to apply cleanly to 2022.3.29

diff --git a/pymatgen/symmetry/settings.py b/pymatgen/symmetry/settings.py
index 1e43ac31b..80a347cfa 100644
--- a/pymatgen/symmetry/settings.py
+++ b/pymatgen/symmetry/settings.py
@@ -11,6 +11,8 @@ import re
 from fractions import Fraction
 
 import numpy as np
+from sympy import Matrix
+from sympy.parsing.sympy_parser import parse_expr
 
 from pymatgen.core.lattice import Lattice
 from pymatgen.core.operations import MagSymmOp, SymmOp
@@ -105,6 +107,7 @@ class JonesFaithfulTransformation:
             b_change, o_shift = transformation_string.split(";")
             basis_change = b_change.split(",")
             origin_shift = o_shift.split(",")
+
             # add implicit multiplication symbols
             basis_change = [
                 re.sub(
@@ -115,16 +118,23 @@ class JonesFaithfulTransformation:
                 )
                 for x in basis_change
             ]
-            # should be fine to use eval here but be mindful for security
-            # reasons
-            # see http://lybniz2.sourceforge.net/safeeval.html
-            # could replace with regex? or sympy expression?
-            P = np.array([eval(x, {"__builtins__": None}, {"a": a, "b": b, "c": c}) for x in basis_change])
-            P = P.transpose()  # by convention
+
+            # basic input sanitation
+            allowed_chars = "0123456789+-*/.abc()"
+            basis_change = ["".join([c for c in string if c in allowed_chars]) for string in basis_change]
+
+            # requires round-trip to sympy to evaluate
+            # (alternatively, `numexpr` looks like a nice solution but requires an additional dependency)
+            basis_change = [
+                parse_expr(string).subs({"a": Matrix(a), "b": Matrix(b), "c": Matrix(c)}) for string in basis_change
+            ]
+            # convert back to numpy, perform transpose by convention
+            P = np.array(basis_change, dtype=float).T[0]
+
             p = [float(Fraction(x)) for x in origin_shift]
             return P, p
-        except Exception:
-            raise ValueError("Failed to parse transformation string.")
+        except Exception as exc:
+            raise ValueError(f"Failed to parse transformation string: {exc}")
 
     @property
     def P(self) -> list[list[float]]:
